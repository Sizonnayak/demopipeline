# -*- coding: utf-8 -*-
"""pancreas-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LW4paebhRZYBkvSvyz01Bym_MudhGkpB
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.optimizers import Adam
from sklearn.model_selection import train_test_split
from tensorflow.keras.losses import binary_crossentropy
import tensorflow.keras.backend as K

image_path = "/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B1 (Ins) L.tif"
image = cv2.imread(image_path)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
image = cv2.resize(image, (256, 256))

hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
lower_brown = np.array([10, 50, 20])
upper_brown = np.array([30, 255, 200])
mask = cv2.inRange(hsv, lower_brown, upper_brown)

"""plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(image)
plt.subplot(1, 2, 2)
plt.title("Segmented Infected Area")
plt.imshow(mask, cmap='gray')
plt.show()
"""

import cv2
import numpy as np

image = cv2.imread('/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B1 (Ins) L.tif')

gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

_, thresholded = cv2.threshold(gray, 100, 255, cv2.THRESH_BINARY)

infected_pixels = np.sum(thresholded == 255)

total_pixels = thresholded.size

percentage_infected = (infected_pixels / total_pixels) * 100

print(f"Percentage of infected area: {percentage_infected:.2f}%")

X = np.expand_dims(image, axis=0) / 255.0
Y = np.expand_dims(mask, axis=0) / 255.0
X_train, Y_train = X, Y
X_test, Y_test = X, Y

def dice_loss(y_true, y_pred):
    smooth = 1.
    y_true_f = K.flatten(y_true)
    y_pred_f = K.flatten(y_pred)
    intersection = K.sum(y_true_f * y_pred_f)
    return 1 - ((2. * intersection + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth))

def build_unet():
    inputs = keras.Input(shape=(256, 256, 3))
    x = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(inputs)
    x = layers.MaxPooling2D((2, 2))(x)
    x = layers.Conv2D(128, (3, 3), activation='relu', padding='same')(x)
    x = layers.MaxPooling2D((2, 2))(x)
    x = layers.Conv2D(256, (3, 3), activation='relu', padding='same')(x)
    x = layers.Conv2DTranspose(128, (3, 3), strides=2, activation='relu', padding='same')(x)
    x = layers.Conv2DTranspose(64, (3, 3), strides=2, activation='relu', padding='same')(x)
    outputs = layers.Conv2D(1, (1, 1), activation='sigmoid', padding='same')(x)

    model = keras.Model(inputs, outputs)
    model.compile(optimizer=Adam(learning_rate=0.001), loss=dice_loss, metrics=['accuracy'])
    return model

model = build_unet()
model.summary()

import cv2
import numpy as np

# Define target image size
IMG_SIZE = (256, 256)

X_resized = []
for img in X:  # Assuming X is a list of images
    resized_img = cv2.resize(img, IMG_SIZE, interpolation=cv2.INTER_AREA)
    X_resized.append(resized_img)

X_resized = np.array(X_resized)

print(X_resized.shape)  # Should be (num_samples, 256, 256, 3)

import numpy as np
import cv2
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.optimizers import Adam
import tensorflow.keras.backend as K

image_path = "/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B1 (Ins) L.tif"
image = cv2.imread(image_path)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
image = cv2.resize(image, (256, 256))

hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
lower_brown = np.array([5, 50, 50])
upper_brown = np.array([30, 255, 255])
mask = cv2.inRange(hsv, lower_brown, upper_brown)

kernel = np.ones((5,5), np.uint8)
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(image)
plt.subplot(1, 2, 2)
plt.title("Segmented Infected Area")
plt.imshow(mask, cmap='gray')
plt.show()

X = np.expand_dims(image, axis=0) / 255.0
Y = np.expand_dims(mask, axis=0) / 255.0
X_train, Y_train = X, Y
X_test, Y_test = X, Y

import cv2
import numpy as np

image = cv2.imread('/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B1 (Ins) L.tif')

gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

_, thresholded = cv2.threshold(gray, 100, 255, cv2.THRESH_BINARY)

infected_pixels = np.sum(thresholded == 255)

total_pixels = thresholded.size

percentage_infected = (infected_pixels / total_pixels) * 100

print(f"Percentage of infected area: {percentage_infected:.2f}%")

def dice_loss(y_true, y_pred):
    smooth = 1.
    y_true_f = K.flatten(y_true)
    y_pred_f = K.flatten(y_pred)
    intersection = K.sum(y_true_f * y_pred_f)
    return 1 - ((2. * intersection + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth))

def build_unet():
    inputs = keras.Input(shape=(256, 256, 3))
    x = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(inputs)
    x = layers.MaxPooling2D((2, 2))(x)
    x = layers.Conv2D(128, (3, 3), activation='relu', padding='same')(x)
    x = layers.MaxPooling2D((2, 2))(x)
    x = layers.Conv2D(256, (3, 3), activation='relu', padding='same')(x)
    x = layers.Conv2DTranspose(128, (3, 3), strides=2, activation='relu', padding='same')(x)
    x = layers.Conv2DTranspose(64, (3, 3), strides=2, activation='relu', padding='same')(x)
    outputs = layers.Conv2D(1, (1, 1), activation='sigmoid', padding='same')(x)
    model = keras.Model(inputs, outputs)
    model.compile(optimizer=Adam(learning_rate=0.001), loss=dice_loss, metrics=['accuracy'])
    return model

model = build_unet()
model.summary()

model.fit(X_train, Y_train, epochs=50, batch_size=2, validation_data=(X_test, Y_test))

predicted_mask = model.predict(np.array([X_test[0]]))[0]

cleaned_mask = cv2.morphologyEx(predicted_mask, cv2.MORPH_CLOSE, kernel)

plt.figure(figsize=(5, 5))
plt.title("Predicted Infected Area")
plt.imshow(cleaned_mask.squeeze(), cmap='gray')
plt.show()

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.layers import Conv2D, UpSampling2D, Input, Concatenate
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from sklearn.model_selection import train_test_split
import cv2
import os

def preprocess_image(image_path, target_size=(256, 256)):
    """Load and preprocess image."""
    image = load_img(image_path, target_size=target_size)
    image = img_to_array(image) / 255.0
    return image

def create_unet(input_shape=(256, 256, 3)):
    """Builds a U-Net model with a ResNet50 encoder."""
    base_model = ResNet50(include_top=False, weights='imagenet', input_tensor=Input(shape=input_shape))

    x = base_model.output
    x = UpSampling2D((2, 2))(x)
    x = Conv2D(128, (3, 3), activation='relu', padding='same')(x)
    x = UpSampling2D((2, 2))(x)
    x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = UpSampling2D((2, 2))(x)
    x = Conv2D(32, (3, 3), activation='relu', padding='same')(x)
    x = UpSampling2D((2, 2))(x)
    x = Conv2D(16, (3, 3), activation='relu', padding='same')(x)
    outputs = Conv2D(1, (1, 1), activation='sigmoid', padding='same')(x)

    model = Model(inputs=base_model.input, outputs=outputs)
    model.compile(optimizer=Adam(learning_rate=0.001), loss='binary_crossentropy', metrics=['accuracy'])

    return model

image_path = '/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B1 (Ins) L.tif'
image = preprocess_image(image_path)
input_image = np.expand_dims(image, axis=0)

model = create_unet()

predicted_mask = model.predict(input_image)

plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(image)
plt.title("Original Image")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(predicted_mask.squeeze(), cmap='twilight', alpha=0.5)
plt.title("Predicted Mask")
plt.axis("off")
plt.show()

import os
import numpy as np
import tensorflow as tf
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
from tensorflow.keras.applications import ResNet50, EfficientNetB0
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from tensorflow.keras import layers
from transformers import ViTFeatureExtractor, ViTForImageClassification

def load_and_preprocess_image(image_path, target_size=(224, 224)):
    img = load_img(image_path, target_size=target_size)
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = img_array / 255.0
    return img_array

image_path = '/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B1 (Ins) L.tif'
image = load_and_preprocess_image(image_path)

labels = np.ones(len(images))

labels = np.concatenate((np.ones(len(images) // 2), np.zeros(len(images) - len(images) // 2)))

import tensorflow as tf
from tensorflow.keras.applications import ResNet50
from tensorflow.keras import layers

def resnet_classifier():
    base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
    x = base_model.output
    x = layers.GlobalAveragePooling2D()(x)
    x = layers.Dense(1, activation='sigmoid')(x)  # Binary classification
    model = tf.keras.models.Model(inputs=base_model.input, outputs=x)

    # Compile with AUC metric
    model.compile(optimizer='adam',
                  loss='binary_crossentropy',
                  metrics=[tf.keras.metrics.AUC(name="auc")])

    return model

import tensorflow as tf
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras import layers

def efficientnet_classifier():
    base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
    x = base_model.output
    x = layers.GlobalAveragePooling2D()(x)
    x = layers.Dense(1, activation='sigmoid')(x)  # Binary classification
    model = tf.keras.models.Model(inputs=base_model.input, outputs=x)

    # Compile with AUC metric
    model.compile(optimizer='adam',
                  loss='binary_crossentropy',
                  metrics=[tf.keras.metrics.AUC(name="auc")])

    return model

def get_predictions(image):
    resnet_model = resnet_classifier()
    resnet_pred = resnet_model.predict(image)
    efficientnet_model = efficientnet_classifier()
    efficientnet_pred = efficientnet_model.predict(image)

    return resnet_pred, efficientnet_pred

resnet_pred, efficientnet_pred = get_predictions(image)
resnet_pred_binary = (resnet_pred > 0.5).astype(int)
efficientnet_pred_binary = (efficientnet_pred > 0.5).astype(int)

print(f"ResNet50 Prediction: {resnet_pred_binary}")
print(f"EfficientNetB0 Prediction: {efficientnet_pred_binary}")

true_label = np.array([1])
print("ResNet50 Classification Report:")
print(classification_report(true_label, resnet_pred_binary))

print("EfficientNetB0 Classification Report:")
print(classification_report(true_label, efficientnet_pred_binary))

def plot_confusion_matrix(true_label, pred_binary, model_name):
    cm = confusion_matrix(true_label, pred_binary)
    plt.figure(figsize=(5, 5))
    plt.imshow(cm, cmap='Blues', interpolation='nearest')
    plt.title(f"Confusion Matrix - {model_name}")
    plt.colorbar()
    plt.xlabel("Predicted Label")
    plt.ylabel("True Label")
    plt.show()

plot_confusion_matrix(true_label, resnet_pred_binary, "ResNet50")
plot_confusion_matrix(true_label, efficientnet_pred_binary, "EfficientNetB0")

models = ['ResNet50', 'EfficientNetB0']
f1_scores = [
    classification_report(true_label, resnet_pred_binary, output_dict=True)['1']['f1-score'],
    classification_report(true_label, efficientnet_pred_binary, output_dict=True)['1']['f1-score'],
]

plt.bar(models, f1_scores)
plt.ylabel('F1 Score')
plt.title('Model Performance Comparison')
plt.show()

import os
import numpy as np
import cv2
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.applications import EfficientNetB0, ResNet50, VGG16
from tensorflow.keras.preprocessing.image import img_to_array
from sklearn.metrics import roc_curve, auc

def load_images_from_folder(folder):
    images = []
    for filename in os.listdir("/Users/pratyushmaharana/Image/Pancreas/Large/INS/"):
        if filename.endswith(".tif"):
            img = cv2.imread(os.path.join(folder, filename))
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            img = cv2.resize(img, (224, 224))
            img = img_to_array(img) / 255.0
            images.append(img)
    return np.array(images)

def build_model(base_model):
    x = base_model.output
    x = tf.keras.layers.GlobalAveragePooling2D()(x)
    x = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    model = tf.keras.models.Model(inputs=base_model.input, outputs=x)
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=[tf.keras.metrics.AUC()])
    return model

data_path = "/Users/pratyushmaharana/Image/Pancreas/Large/INS/"
images = load_images_from_folder(data_path)
labels = np.ones(len(images))

models = {
    "EfficientNetB0": build_model(EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))),
    "ResNet50": build_model(ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))),
    "VGG16": build_model(VGG16(weights='imagenet', include_top=False, input_shape=(224, 224, 3)))
}

labels = np.ones(len(images))

labels = np.concatenate((np.ones(len(images) // 2), np.zeros(len(images) - len(images) // 2)))

def preprocess_image(img_path):
    img = cv2.imread("/Users/pratyushmaharana/Image/Pancreas/Large/INS/")
    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    lower_brown = np.array([10, 50, 50])
    upper_brown = np.array([30, 255, 255])
    mask = cv2.inRange(img, lower_brown, upper_brown)
    img = cv2.bitwise_and(img, img, mask=mask)
    img = cv2.cvtColor(img, cv2.COLOR_HSV2RGB)
    img = cv2.resize(img, (224, 224))
    img = img / 255.0
    return img

from tensorflow.keras.preprocessing.image import ImageDataGenerator

datagen = ImageDataGenerator(
    rotation_range=30,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True,
    brightness_range=[0.8, 1.2],
    zoom_range=0.2
)

import tensorflow as tf
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras import layers

def fine_tuned_efficientnet():
    base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
    base_model.trainable = True
    x = layers.GlobalAveragePooling2D()(base_model.output)
    x = layers.Dense(256, activation='relu')(x)
    x = layers.Dropout(0.3)(x)
    output = layers.Dense(1, activation='sigmoid')(x)

    model = tf.keras.models.Model(inputs=base_model.input, outputs=output)
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001),
                  loss='binary_crossentropy',
                  metrics=[tf.keras.metrics.AUC()])
    return model

from sklearn.metrics import precision_recall_curve

precision, recall, _ = precision_recall_curve(labels, y_pred)
plt.plot(recall, precision, marker='.', label=f'{name}')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title(f'Precision-Recall Curve for {name}')
plt.legend()
plt.show()

for name, model in models.items():
    print(f"Processing {name}...")
    y_pred = model.predict(images)
    fpr, tpr, _ = roc_curve(labels, y_pred)
    roc_auc = auc(fpr, tpr)

    # Plot ROC Curve
    plt.figure()
    plt.plot(fpr, tpr, color='blue', lw=2, label=f'{name} (AUC = {roc_auc:.2f})')
    plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title(f'ROC Curve for {name}')
    plt.legend(loc='lower right')
    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

def extract_brown_stain(image_path):
    img = cv2.imread("/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B4 (Ins) L.tif")
    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    lower_brown = np.array([5, 50, 50])
    upper_brown = np.array([30, 255, 255])

    mask = cv2.inRange(img_hsv, lower_brown, upper_brown)
    result = cv2.bitwise_and(img, img, mask=mask)

    return result, mask

# Test on an image
image_path = "/Users/pratyushmaharana/Image/Pancreas/Large/INS/T-8, B4 (Ins) L.tif"
segmented, mask = extract_brown_stain(image_path)

plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(segmented, cv2.COLOR_BGR2RGB))
plt.title("Brown-Stain Segmentation")

plt.subplot(1, 2, 2)
plt.imshow(mask, cmap='twilight')
plt.title("Binary Mask")
plt.show()

